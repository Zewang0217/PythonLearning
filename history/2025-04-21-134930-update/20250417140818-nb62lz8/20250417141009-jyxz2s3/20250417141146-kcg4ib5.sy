{"ID":"20250417141146-kcg4ib5","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250417141146-kcg4ib5","title":"列表","type":"doc","updated":"20250421134638"},"Children":[{"ID":"20250417141146-jfdhmbh","Type":"NodeList","ListData":{},"Properties":{"id":"20250417141146-jfdhmbh","updated":"20250417175923"},"Children":[{"ID":"20250417175849-xlmu1t6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20250417175849-xlmu1t6","updated":"20250417175923"},"Children":[{"ID":"20250417175849-7dgspgb","Type":"NodeParagraph","Properties":{"id":"20250417175849-7dgspgb","updated":"20250417175923"},"Children":[{"Type":"NodeText","Data":"可变数据类型：添加元素、删除元素、清空元素、排序反转"}]}]}]},{"ID":"20250421134622-opbboat","Type":"NodeParagraph","Properties":{"id":"20250421134622-opbboat","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"在开始本节课的内容之前，我们先给大家一个编程任务，将一颗色子掷 6000 次，统计每种点数出现的次数。这个任务对大家来说应该是非常简单的，我们可以用 1 到 6 均匀分布的随机数来模拟掷色子，然后用 6 个变量分别记录每个点数出现的次数，相信通过前面的学习，大家都能比较顺利的写出下面的代码。"}]},{"ID":"20250421134622-s1a4w2k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-s1a4w2k","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n将一颗色子掷6000次，统计每种点数出现的次数\n\nAuthor: 骆昊\nVersion: 1.0\n\"\"\"\nimport random\n\nf1 = 0\nf2 = 0\nf3 = 0\nf4 = 0\nf5 = 0\nf6 = 0\nfor _ in range(6000):\n    face = random.randrange(1, 7)\n    if face == 1:\n        f1 += 1\n    elif face == 2:\n        f2 += 1\n    elif face == 3:\n        f3 += 1\n    elif face == 4:\n        f4 += 1\n    elif face == 5:\n        f5 += 1\n    else:\n        f6 += 1\nprint(f'1点出现了{f1}次')\nprint(f'2点出现了{f2}次')\nprint(f'3点出现了{f3}次')\nprint(f'4点出现了{f4}次')\nprint(f'5点出现了{f5}次')\nprint(f'6点出现了{f6}次')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-1dp92l9","Type":"NodeParagraph","Properties":{"id":"20250421134622-1dp92l9","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"上面的代码非常有多么“丑陋”相信就不用我多说了。当然，更为可怕的是，如果我们要掷两颗或者掷更多的色子，然后统计每种点数出现的次数，那就需要定义更多的变量，写更多的分支结构，大家想想都会感到恶心。讲到这里，相信大家心中已经有一个疑问了：有没有办法用一个变量来保存多个数据，有没有办法用统一的代码对多个数据进行操作？答案是肯定的，在 Python 语言中我们可以通过容器型变量来保存和操作多个数据，我们首先为大家介绍列表（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​）这种新的数据类型。"}]},{"ID":"20250421134622-7lqwbzt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134622-7lqwbzt","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"创建列表"}]},{"ID":"20250421134622-ekmy72q","Type":"NodeParagraph","Properties":{"id":"20250421134622-ekmy72q","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"在 Python 中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"列表是由一系元素按特定顺序构成的数据序列"},{"Type":"NodeText","Data":"，这就意味着如果我们定义一个列表类型的变量，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以用它来保存多个数据"},{"Type":"NodeText","Data":"。在 Python 中，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。"}]},{"ID":"20250421134622-1k3t9ek","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-1k3t9ek","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items1 = [35, 12, 99, 68, 55, 35, 87]\nitems2 = ['Python', 'Java', 'Go', 'Kotlin']\nitems3 = [100, 12.3, 'Python', True]\nprint(items1)  # [35, 12, 99, 68, 55, 35, 87]\nprint(items2)  # ['Python', 'Java', 'Go', 'Kotlin']\nprint(items3)  # [100, 12.3, 'Python', True]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-j2mlods","Type":"NodeBlockquote","Properties":{"id":"20250421134622-j2mlods","updated":"20250421134622"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134622-mjtnubk","Type":"NodeParagraph","Properties":{"id":"20250421134622-mjtnubk","updated":"20250421134622"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：列表中可以有重复元素，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items1"},{"Type":"NodeText","Data":"​中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"35"},{"Type":"NodeText","Data":"​；列表中可以有不同类型的元素，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items3"},{"Type":"NodeText","Data":"​中有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"​类型、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"​类型、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"str"},{"Type":"NodeText","Data":"​类型和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​类型的元素，但是我们通常并不建议将不同类型的元素放在同一个列表中，主要是操作起来极为不便。"}]}]},{"ID":"20250421134622-0r1as0c","Type":"NodeParagraph","Properties":{"id":"20250421134622-0r1as0c","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"type"},{"Type":"NodeText","Data":"​函数来查看变量的类型，有兴趣的小伙伴可以自行查看上面的变量"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items1"},{"Type":"NodeText","Data":"​到底是什么类型。因为列表可以保存多个元素，它是一种容器型的数据类型，所以我们在给列表类型的变量起名字时，变量名通常用复数形式的单词。"}]},{"ID":"20250421134622-hh7p3z5","Type":"NodeParagraph","Properties":{"id":"20250421134622-hh7p3z5","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"除此以外，还可以通过 Python 内置的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​函数将其他序列变成列表。准确的说，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​并不是一个普通的函数，它是创建列表对象的构造器，后面的课程会为大家介绍对象和构造器这些概念。"}]},{"ID":"20250421134622-dpy8yaf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-dpy8yaf","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items4 = list(range(1, 10))\nitems5 = list('hello')\nprint(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(items5)  # ['h', 'e', 'l', 'l', 'o']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-9yljbo4","Type":"NodeBlockquote","Properties":{"id":"20250421134622-9yljbo4","updated":"20250421134622"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134622-oc69nn0","Type":"NodeParagraph","Properties":{"id":"20250421134622-oc69nn0","updated":"20250421134622"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"range(1, 10)"},{"Type":"NodeText","Data":"​会产生"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"9"},{"Type":"NodeText","Data":"​的整数序列，给到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list"},{"Type":"NodeText","Data":"​构造器中，会创建出由"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"9"},{"Type":"NodeText","Data":"​的整数构成的列表。字符串是字符构成的序列，上面的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"list('hello')"},{"Type":"NodeText","Data":"​用字符串"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hello"},{"Type":"NodeText","Data":"​的字符作为列表元素，创建了列表对象。"}]}]},{"ID":"20250421134622-5s04j70","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134622-5s04j70","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"列表的运算"}]},{"ID":"20250421134622-p3ifz78","Type":"NodeParagraph","Properties":{"id":"20250421134622-p3ifz78","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+"},{"Type":"NodeText","Data":"​运算符实现两个列表的拼接，拼接运算会将两个列表中的元素连接起来放到一个列表中，代码如下所示。"}]},{"ID":"20250421134622-wqzvip1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-wqzvip1","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items5 = [35, 12, 99, 45, 66]\nitems6 = [45, 58, 29]\nitems7 = ['Python', 'Java', 'JavaScript']\nprint(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]\nprint(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']\nitems5 += items6\nprint(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-al8x6f2","Type":"NodeParagraph","Properties":{"id":"20250421134622-al8x6f2","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*"},{"Type":"NodeText","Data":"​运算符实现列表的重复运算，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*"},{"Type":"NodeText","Data":"​运算符会将列表元素重复指定的次数，我们在上面的代码中增加两行，如下所示。"}]},{"ID":"20250421134622-lzi06fl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-lzi06fl","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]\nprint(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-ww08po8","Type":"NodeParagraph","Properties":{"id":"20250421134622-ww08po8","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"in"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"not in"},{"Type":"NodeText","Data":"​运算符判断一个元素在不在列表中，我们在上面的代码代码中再增加两行，如下所示。"}]},{"ID":"20250421134622-5ye74d6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-5ye74d6","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"print(29 in items6)  # True\nprint(99 in items6)  # False\nprint('C++' not in items7)     # True\nprint('Python' not in items7)  # False\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-ujh6h1i","Type":"NodeParagraph","Properties":{"id":"20250421134622-ujh6h1i","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"由于列表中有多个元素，而且元素是按照特定顺序放在列表中的，所以当我们想操作列表中的某个元素时，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​运算符，通过在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​中指定元素的位置来访问该元素，这种运算称为索引运算。需要说明的是，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​的元素位置可以是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N - 1"},{"Type":"NodeText","Data":"​的整数，也可以是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-N"},{"Type":"NodeText","Data":"​的整数，分别称为正向索引和反向索引，其中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​代表列表元素的个数。对于正向索引，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[0]"},{"Type":"NodeText","Data":"​可以访问列表中的第一个元素，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[N - 1]"},{"Type":"NodeText","Data":"​可以访问最后一个元素；对于反向索引，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[-1]"},{"Type":"NodeText","Data":"​可以访问列表中的最后一个元素，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[-N]"},{"Type":"NodeText","Data":"​可以访问第一个元素，代码如下所示。"}]},{"ID":"20250421134622-hyhvcrj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-hyhvcrj","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']\nprint(items8[0])   # apple\nprint(items8[2])   # pitaya\nprint(items8[4])   # watermelon\nitems8[2] = 'durian'\nprint(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']\nprint(items8[-5])  # 'apple'\nprint(items8[-4])  # 'waxberry'\nprint(items8[-1])  # watermelon\nitems8[-4] = 'strawberry'\nprint(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-p6ybl6n","Type":"NodeParagraph","Properties":{"id":"20250421134622-p6ybl6n","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"在使用索引运算的时候要避免出现索引越界的情况，对于上面的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items8"},{"Type":"NodeText","Data":"​，如果我们访问"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items8[5]"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items8[-6]"},{"Type":"NodeText","Data":"​，就会引发"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IndexError"},{"Type":"NodeText","Data":"​错误，导致程序崩溃，对应的错误信息是："},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"list index out of range"},{"Type":"NodeText","Data":"，翻译成中文就是“数组索引超出范围”。因为对于只有五个元素的列表"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"items8"},{"Type":"NodeText","Data":"​，有效的正向索引是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"4"},{"Type":"NodeText","Data":"​，有效的反向索引是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-5"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20250421134622-c04i9fe","Type":"NodeParagraph","Properties":{"id":"20250421134622-c04i9fe","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"如果希望一次性访问列表中的多个元素，我们可以使用切片运算。切片运算是形如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[startstride]"},{"Type":"NodeText","Data":"​的运算符，其中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":"​代表访问列表元素的起始位置，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"end"},{"Type":"NodeText","Data":"​代表访问列表元素的终止位置（终止位置的元素无法访问），而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"stride"},{"Type":"NodeText","Data":"​则代表了跨度，简单的说就是位置的增量，比如我们访问的第一个元素在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":"​位置，那么第二个元素就在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start + stride"},{"Type":"NodeText","Data":"​位置，当然"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start + stride"},{"Type":"NodeText","Data":"​要小于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"end"},{"Type":"NodeText","Data":"​。我们给上面的代码增加下面的语句，来使用切片运算符访问列表元素。"}]},{"ID":"20250421134622-xtb68hu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-xtb68hu","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"print(items8[1:3:1])     # ['strawberry', 'durian']\nprint(items8[0:3:1])     # ['apple', 'strawberry', 'durian']\nprint(items8[0:5:2])     # ['apple', 'durian', 'watermelon']\nprint(items8[-4:-2:1])   # ['strawberry', 'durian']\nprint(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-7pzp85q","Type":"NodeBlockquote","Properties":{"id":"20250421134622-7pzp85q","updated":"20250421134622"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134622-cadqrlu","Type":"NodeParagraph","Properties":{"id":"20250421134622-cadqrlu","updated":"20250421134622"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"提醒"},{"Type":"NodeText","Data":"：大家可以看看上面代码中的最后一行，想一想当跨度为负数时，切片运算是如何访问元素的。"}]}]},{"ID":"20250421134622-wixnejv","Type":"NodeParagraph","Properties":{"id":"20250421134622-wixnejv","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"start"},{"Type":"NodeText","Data":"​值等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​，那么在使用切片运算符时可以将其省略；如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"end"},{"Type":"NodeText","Data":"​值等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​代表列表元素的个数，那么在使用切片运算符时可以将其省略；如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"stride"},{"Type":"NodeText","Data":"​值等于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​，那么在使用切片运算符时也可以将其省略。所以，下面的代码跟上面的代码作用完全相同。"}]},{"ID":"20250421134622-6h86ltu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-6h86ltu","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"print(items8[1:3])     # ['strawberry', 'durian']\nprint(items8[:3:1])    # ['apple', 'strawberry', 'durian']\nprint(items8[::2])     # ['apple', 'durian', 'watermelon']\nprint(items8[-4:-2])   # ['strawberry', 'durian']\nprint(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-ypjvpxy","Type":"NodeParagraph","Properties":{"id":"20250421134622-ypjvpxy","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"事实上，我们还可以通过切片操作修改列表中的元素，例如我们给上面的代码再加上一行，大家可以看看这里的输出。"}]},{"ID":"20250421134622-s15ldle","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-s15ldle","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items8[1:3] = ['x', 'o']\nprint(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-4h45div","Type":"NodeParagraph","Properties":{"id":"20250421134622-4h45div","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"两个列表还可以做关系运算，我们可以比较两个列表是否相等，也可以给两个列表比大小，代码如下所示。"}]},{"ID":"20250421134622-txl23j7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-txl23j7","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"nums1 = [1, 2, 3, 4]\nnums2 = list(range(1, 5))\nnums3 = [3, 2, 1]\nprint(nums1 == nums2)  # True\nprint(nums1 != nums2)  # False\nprint(nums1 \u003c= nums3)  # True\nprint(nums2 \u003e= nums3)  # False\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-2vv02kr","Type":"NodeBlockquote","Properties":{"id":"20250421134622-2vv02kr","updated":"20250421134622"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134622-ug0em4m","Type":"NodeParagraph","Properties":{"id":"20250421134622-ug0em4m","updated":"20250421134622"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：上面的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​对应元素完全相同，所以"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":"​运算的结果是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"True"},{"Type":"NodeText","Data":"​。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums3"},{"Type":"NodeText","Data":"​的比较，由于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​的第一个元素"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​小于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums3"},{"Type":"NodeText","Data":"​的第一个元素"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"3"},{"Type":"NodeText","Data":"​，所以"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2 \u0026gt;= nums3"},{"Type":"NodeText","Data":"​比较的结果是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"False"},{"Type":"NodeText","Data":"​。两个列表的关系运算在实际工作并不那么常用，如果实在不理解就跳过吧，不用纠结。"}]}]},{"ID":"20250421134622-8q76u0z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134622-8q76u0z","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"元素的遍历"}]},{"ID":"20250421134622-gnp05r0","Type":"NodeParagraph","Properties":{"id":"20250421134622-gnp05r0","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"如果想逐个取出列表中的元素，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for-in"},{"Type":"NodeText","Data":"​循环的，有以下两种做法。"}]},{"ID":"20250421134622-myh8w4m","Type":"NodeParagraph","Properties":{"id":"20250421134622-myh8w4m","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"方法一：在循环结构中通过索引运算，遍历列表元素。"}]},{"ID":"20250421134622-do9hb2c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-do9hb2c","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"languages = ['Python', 'Java', 'C++', 'Kotlin']\nfor index in range(len(languages)):\n    print(languages[index])\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-hw0s9cf","Type":"NodeParagraph","Properties":{"id":"20250421134622-hw0s9cf","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20250421134622-hllr6ll","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-hllr6ll","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bm90cmFuc2xhdGU="},{"Type":"NodeCodeBlockCode","Data":"Python\nJava\nC++\nKotlin\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-605twk5","Type":"NodeBlockquote","Properties":{"id":"20250421134622-605twk5","updated":"20250421134622"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134622-vg6rz8r","Type":"NodeParagraph","Properties":{"id":"20250421134622-vg6rz8r","updated":"20250421134622"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：上面的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"len"},{"Type":"NodeText","Data":"​函数可以获取列表元素的个数"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"range(N)"},{"Type":"NodeText","Data":"​则构成了从"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N-1"},{"Type":"NodeText","Data":"​的范围，刚好可以作为列表元素的索引。"}]}]},{"ID":"20250421134622-1pqs6su","Type":"NodeParagraph","Properties":{"id":"20250421134622-1pqs6su","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"方法二：直接对列表做循环，循环变量就是列表元素的代表。"}]},{"ID":"20250421134622-qxcavz1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-qxcavz1","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"languages = ['Python', 'Java', 'C++', 'Kotlin']\nfor language in languages:\n    print(language)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-ivc1n34","Type":"NodeParagraph","Properties":{"id":"20250421134622-ivc1n34","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20250421134622-cte0d7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-cte0d7x","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"bm90cmFuc2xhdGU="},{"Type":"NodeCodeBlockCode","Data":"Python\nJava\nC++\nKotlin\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-fkkg4m0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134622-fkkg4m0","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250421134622-c87cq25","Type":"NodeParagraph","Properties":{"id":"20250421134622-c87cq25","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"讲到这里，我们可以用列表的知识来重构上面“掷色子统计每种点数出现次数”的代码。"}]},{"ID":"20250421134622-k4fcp53","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134622-k4fcp53","updated":"20250421134622"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n将一颗色子掷6000次，统计每种点数出现的次数\n\nAuthor: 骆昊\nVersion: 1.1\n\"\"\"\nimport random\n\ncounters = [0] * 6\n# 模拟掷色子记录每种点数出现的次数\nfor _ in range(6000):\n    face = random.randrange(1, 7)\n    counters[face - 1] += 1\n# 输出每种点数出现的次数\nfor face in range(1, 7):\n    print(f'{face}点出现了{counters[face - 1]}次')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134622-zop5tzp","Type":"NodeParagraph","Properties":{"id":"20250421134622-zop5tzp","updated":"20250421134622"},"Children":[{"Type":"NodeText","Data":"上面的代码中，我们用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"counters"},{"Type":"NodeText","Data":"​列表中的六个元素分别表示 1 到 6 点出现的次数，最开始的时候六个元素的值都是 0。接下来，我们用 1 到 6 均匀分布的随机数模拟掷色子，如果摇出 1 点，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"counters[0]"},{"Type":"NodeText","Data":"​的值加 1，如果摇出 2 点，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"counters[1]"},{"Type":"NodeText","Data":"​的值加 1，以此类推。大家感受一下，由于使用了列表类型加上循环结构，我们对数据的处理是批量性的，这就使得修改后的代码比之前的代码要简单优雅得多。"}]},{"ID":"20250421134638-pqi3omo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134638-pqi3omo","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表的方法"}]},{"ID":"20250421134638-wjrt80f","Type":"NodeParagraph","Properties":{"id":"20250421134638-wjrt80f","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表类型的变量拥有很多方法可以帮助我们操作一个列表，假设我们有名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"foos"},{"Type":"NodeText","Data":"​的列表，列表有名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bar"},{"Type":"NodeText","Data":"​的方法，那么使用列表方法的语法是："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"foos.bar()"},{"Type":"NodeText","Data":"​，这是一种通过对象引用调用对象方法的语法。后面我们讲面向对象编程的时候，还会对这种语法进行详细的讲解，这种语法也称为给对象发消息。"}]},{"ID":"20250421134638-6muh4l9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250421134638-6muh4l9","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"添加和删除元素"}]},{"ID":"20250421134638-onu6zba","Type":"NodeParagraph","Properties":{"id":"20250421134638-onu6zba","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表是一种可变容器，可变容器指的是我们可以向容器中添加元素、可以从容器移除元素，也可以修改现有容器中的元素。我们可以使用列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":"​方法向列表中追加元素，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"insert"},{"Type":"NodeText","Data":"​方法向列表中插入元素。追加指的是将元素添加到列表的末尾，而插入则是在指定的位置添加新元素，大家可以看看下面的代码。"}]},{"ID":"20250421134638-yjq0t6z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-yjq0t6z","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"languages = ['Python', 'Java', 'C++']\nlanguages.append('JavaScript')\nprint(languages)  # ['Python', 'Java', 'C++', 'JavaScript']\nlanguages.insert(1, 'SQL')\nprint(languages)  # ['Python', 'SQL', 'Java', 'C++', 'JavaScript']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-m210alx","Type":"NodeParagraph","Properties":{"id":"20250421134638-m210alx","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"我们可以用列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"remove"},{"Type":"NodeText","Data":"​方法从列表中删除指定元素，需要注意的是，如果要删除的元素并不在列表中，会引发"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueError"},{"Type":"NodeText","Data":"​错误导致程序崩溃，所以建议大家在删除元素时，先用之前讲过的成员运算做一个判断。我们还可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法从列表中删除元素，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法默认删除列表中的最后一个元素，当然也可以给一个位置，删除指定位置的元素。在使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法删除元素时，如果索引的值超出了范围，会引发"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IndexError"},{"Type":"NodeText","Data":"​异常，导致程序崩溃。除此之外，列表还有一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear"},{"Type":"NodeText","Data":"​方法，可以清空列表中的元素，代码如下所示。"}]},{"ID":"20250421134638-300ohie","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-300ohie","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"languages = ['Python', 'SQL', 'Java', 'C++', 'JavaScript']\nif 'Java' in languages:\n    languages.remove('Java')\nif 'Swift' in languages:\n    languages.remove('Swift')\nprint(languages)  # ['Python', 'SQL', C++', 'JavaScript']\nlanguages.pop()\ntemp = languages.pop(1)\nprint(temp)       # SQL\nlanguages.append(temp)\nprint(languages)  # ['Python', C++', 'SQL']\nlanguages.clear()\nprint(languages)  # []\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-0oc09ux","Type":"NodeBlockquote","Properties":{"id":"20250421134638-0oc09ux","updated":"20250421134638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134638-0mkib4t","Type":"NodeParagraph","Properties":{"id":"20250421134638-0mkib4t","updated":"20250421134638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法删除元素时会得到被删除的元素，上面的代码中，我们将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法删除的元素赋值给了名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"temp"},{"Type":"NodeText","Data":"​的变量。当然如果你愿意，还可以把这个元素再次加入到列表中，正如上面的代码"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"languages.append(temp)"},{"Type":"NodeText","Data":"​所做的那样。"}]}]},{"ID":"20250421134638-8us1ttf","Type":"NodeParagraph","Properties":{"id":"20250421134638-8us1ttf","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"这里还有一个小问题，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"languages"},{"Type":"NodeText","Data":"​列表中有多个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"'Python'"},{"Type":"NodeText","Data":"​，那么我们用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"languages.remove('Python')"},{"Type":"NodeText","Data":"​是删除所有的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"'Python'"},{"Type":"NodeText","Data":"​，还是删除第一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"'Python'"},{"Type":"NodeText","Data":"​，大家可以先猜一猜，然后再自己动手尝试一下。"}]},{"ID":"20250421134638-jbbw0se","Type":"NodeParagraph","Properties":{"id":"20250421134638-jbbw0se","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"从列表中删除元素其实还有一种方式，就是使用 Python 中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"del"},{"Type":"NodeText","Data":"​关键字后面跟要删除的元素，这种做法跟使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优，因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"del"},{"Type":"NodeText","Data":"​对应的底层字节码指令是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"DELETE_SUBSCR"},{"Type":"NodeText","Data":"​，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop"},{"Type":"NodeText","Data":"​对应的底层字节码指令是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CALL_METHOD"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"POP_TOP"},{"Type":"NodeText","Data":"​，如果不理解就不用管它了。"}]},{"ID":"20250421134638-i7exd94","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-i7exd94","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items = ['Python', 'Java', 'C++']\ndel items[1]\nprint(items)  # ['Python', 'C++']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-b32askt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250421134638-b32askt","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"元素位置和频次"}]},{"ID":"20250421134638-lpd6i5f","Type":"NodeParagraph","Properties":{"id":"20250421134638-lpd6i5f","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​方法可以查找某个元素在列表中的索引位置，如果找不到指定的元素，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​方法会引发"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ValueError"},{"Type":"NodeText","Data":"​错误；列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"count"},{"Type":"NodeText","Data":"​方法可以统计一个元素在列表中出现的次数，代码如下所示。"}]},{"ID":"20250421134638-9p2rped","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-9p2rped","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items = ['Python', 'Java', 'Java', 'C++', 'Kotlin', 'Python']\nprint(items.index('Python'))     # 0\n# 从索引位置1开始查找'Python'\nprint(items.index('Python', 1))  # 5\nprint(items.count('Python'))     # 2\nprint(items.count('Kotlin'))     # 1\nprint(items.count('Swfit'))      # 0\n# 从索引位置3开始查找'Java'\nprint(items.index('Java', 3))    # ValueError: 'Java' is not in list\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-76s7zax","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250421134638-76s7zax","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"元素排序和反转"}]},{"ID":"20250421134638-9nbezdi","Type":"NodeParagraph","Properties":{"id":"20250421134638-9nbezdi","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sort"},{"Type":"NodeText","Data":"​操作可以实现列表元素的排序，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"reverse"},{"Type":"NodeText","Data":"​操作可以实现元素的反转，代码如下所示。"}]},{"ID":"20250421134638-z1g0jh9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-z1g0jh9","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items = ['Python', 'Java', 'C++', 'Kotlin', 'Swift']\nitems.sort()\nprint(items)  # ['C++', 'Java', 'Kotlin', 'Python', 'Swift']\nitems.reverse()\nprint(items)  # ['Swift', 'Python', 'Kotlin', 'Java', 'C++']\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-bhpe9sv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134638-bhpe9sv","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表生成式"}]},{"ID":"20250421134638-c5mur91","Type":"NodeParagraph","Properties":{"id":"20250421134638-c5mur91","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"在 Python 中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。下面，我们通过例子来说明使用列表生成式创建列表到底有什么好处。"}]},{"ID":"20250421134638-usqt3hh","Type":"NodeParagraph","Properties":{"id":"20250421134638-usqt3hh","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"场景一：创建一个取值范围在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"99"},{"Type":"NodeText","Data":"​且能被"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"3"},{"Type":"NodeText","Data":"​或者"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"5"},{"Type":"NodeText","Data":"​整除的数字构成的列表。"}]},{"ID":"20250421134638-8damqt3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-8damqt3","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items = []\nfor i in range(1, 100):\n    if i % 3 == 0 or i % 5 == 0:\n        items.append(i)\nprint(items)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-hagiy8p","Type":"NodeParagraph","Properties":{"id":"20250421134638-hagiy8p","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"使用列表生成式做同样的事情，代码如下所示。"}]},{"ID":"20250421134638-5dljglp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-5dljglp","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"items = [i for i in range(1, 100) if i % 3 == 0 or i % 5 == 0]\nprint(items)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-tkywgl5","Type":"NodeParagraph","Properties":{"id":"20250421134638-tkywgl5","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"场景二：有一个整数列表"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":"​，创建一个新的列表"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​中的元素是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":"​中对应元素的平方。"}]},{"ID":"20250421134638-6emjbzf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-6emjbzf","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"nums1 = [35, 12, 97, 64, 55]\nnums2 = []\nfor num in nums1:\n    nums2.append(num ** 2)\nprint(nums2)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-w73u5hn","Type":"NodeParagraph","Properties":{"id":"20250421134638-w73u5hn","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"使用列表生成式做同样的事情，代码如下所示。"}]},{"ID":"20250421134638-3ub8hg1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-3ub8hg1","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"nums1 = [35, 12, 97, 64, 55]\nnums2 = [num ** 2 for num in nums1]\nprint(nums2)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-yrtkh8c","Type":"NodeParagraph","Properties":{"id":"20250421134638-yrtkh8c","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"场景三： 有一个整数列表"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":"​，创建一个新的列表"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​，将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums1"},{"Type":"NodeText","Data":"​中大于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"50"},{"Type":"NodeText","Data":"​的元素放到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"nums2"},{"Type":"NodeText","Data":"​中。"}]},{"ID":"20250421134638-ejeoych","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-ejeoych","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"nums1 = [35, 12, 97, 64, 55]\nnums2 = []\nfor num in nums1:\n    if num \u003e 50:\n        nums2.append(num)\nprint(nums2)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-ao8ef3c","Type":"NodeParagraph","Properties":{"id":"20250421134638-ao8ef3c","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"使用列表生成式做同样的事情，代码如下所示。"}]},{"ID":"20250421134638-l060n1l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-l060n1l","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"nums1 = [35, 12, 97, 64, 55]\nnums2 = [num for num in nums1 if num \u003e 50]\nprint(nums2)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-fcib6x5","Type":"NodeParagraph","Properties":{"id":"20250421134638-fcib6x5","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"使用列表生成式创建列表不仅代码简单优雅，而且性能上也优于使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for-in"},{"Type":"NodeText","Data":"​循环和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"append"},{"Type":"NodeText","Data":"​方法向空列表中追加元素的方式。为什么说生成式有更好的性能呢，那是因为 Python 解释器的字节码指令中有专门针对生成式的指令（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LIST_APPEND"},{"Type":"NodeText","Data":"​指令）；而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​循环是通过方法调用（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LOAD_METHOD"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CALL_METHOD"},{"Type":"NodeText","Data":"​指令）的方式为列表添加元素，方法调用本身就是一个相对比较耗时的操作。对这一点不理解也没有关系，记住“"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"强烈建议用生成式语法来创建列表"},{"Type":"NodeText","Data":"”这个结论就可以了。"}]},{"ID":"20250421134638-l9ejnvj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134638-l9ejnvj","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"嵌套列表"}]},{"ID":"20250421134638-ex1ex6j","Type":"NodeParagraph","Properties":{"id":"20250421134638-ex1ex6j","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"Python 语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表本身。如果列表中的元素也是列表，那么我们可以称之为嵌套的列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存5个学生3门课程的成绩，可以用如下所示的列表。"}]},{"ID":"20250421134638-pt7vw5t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-pt7vw5t","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"scores = [[95, 83, 92], [80, 75, 82], [92, 97, 90], [80, 78, 69], [65, 66, 89]]\nprint(scores[0])\nprint(scores[0][1])\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-tjw8e0d","Type":"NodeParagraph","Properties":{"id":"20250421134638-tjw8e0d","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"对于上面的嵌套列表，每个元素相当于就是一个学生3门课程的成绩，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[95, 83, 92]"},{"Type":"NodeText","Data":"​，而这个列表中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"83"},{"Type":"NodeText","Data":"​代表了这个学生某一门课的成绩，如果想访问这个值，可以使用两次索引运算"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"scores[0][1]"},{"Type":"NodeText","Data":"​，其中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"scores[0]"},{"Type":"NodeText","Data":"​可以得到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[95, 83, 92]"},{"Type":"NodeText","Data":"​这个列表，再次使用索引运算"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[1]"},{"Type":"NodeText","Data":"​就可以获得该列表中的第二个元素。"}]},{"ID":"20250421134638-nukza2p","Type":"NodeParagraph","Properties":{"id":"20250421134638-nukza2p","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"如果想通过键盘输入的方式来录入5个学生3门课程的成绩并保存在列表中，可以使用如下所示的代码。"}]},{"ID":"20250421134638-yfa0krl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-yfa0krl","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"scores = []\nfor _ in range(5):\n    temp = []\n    for _ in range(3):\n        score = int(input('请输入: '))\n        temp.append(score)\n    scores.append(temp)\nprint(scores)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-tygxczx","Type":"NodeParagraph","Properties":{"id":"20250421134638-tygxczx","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"如果想通过产生随机数的方式来生成5个学生3门课程的成绩并保存在列表中，我们可以使用列表生成式，代码如下所示。"}]},{"ID":"20250421134638-yo5qmf9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-yo5qmf9","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"import random\n\nscores = [[random.randrange(60, 101) for _ in range(3)] for _ in range(5)]\nprint(scores)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-nqg16ha","Type":"NodeBlockquote","Properties":{"id":"20250421134638-nqg16ha","updated":"20250421134638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134638-vk4341z","Type":"NodeParagraph","Properties":{"id":"20250421134638-vk4341z","updated":"20250421134638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：上面的代码"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[random.randrange(60, 101) for _ in range(3)] "},{"Type":"NodeText","Data":"​可以产生由3个随机整数构成的列表，我们把这段代码又放在了另一个列表生成式中作为列表的元素，这样的元素一共生成5个，最终得到了一个嵌套列表。"}]}]},{"ID":"20250421134638-35932k0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134638-35932k0","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"列表的应用"}]},{"ID":"20250421134638-yjeh0jh","Type":"NodeParagraph","Properties":{"id":"20250421134638-yjeh0jh","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"下面我们通过一个双色球随机选号的例子为大家讲解列表的应用。双色球是由中国福利彩票发行管理中心发售的乐透型彩票，每注投注号码由"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"6"},{"Type":"NodeText","Data":"​个红色球和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​个蓝色球组成。红色球号码从"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"33"},{"Type":"NodeText","Data":"​中选择，蓝色球号码从"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"16"},{"Type":"NodeText","Data":"​中选择。每注需要选择"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"6"},{"Type":"NodeText","Data":"​个红色球号码和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​个蓝色球号码，如下所示。"}]},{"ID":"20250421134638-9tzfsgt","Type":"NodeParagraph","Properties":{"id":"20250421134638-9tzfsgt","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://github.com/jackfrued/Python-100-Days/raw/master/Day01-20/res/day09/lottery.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/lottery.png","TextMarkTextContent":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/lottery.png"}]},{"ID":"20250421134638-kjawbkt","Type":"NodeBlockquote","Properties":{"id":"20250421134638-kjawbkt","updated":"20250421134638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134638-pnw07ir","Type":"NodeParagraph","Properties":{"id":"20250421134638-pnw07ir","updated":"20250421134638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"提示"},{"Type":"NodeText","Data":"：知乎上有一段对国内各种形式的彩票本质的论述相当精彩，这里分享给大家：“"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"虚构一个不劳而获的人，去忽悠一群想不劳而获的人，最终养活一批真正不劳而获的人"},{"Type":"NodeText","Data":"”。很多对概率没有概念的人，甚至认为彩票中与不中的概率都是 50%；还有很多人认为如果中奖的概率是 1%，那么买 100 次就一定可以中奖，这些都是非常荒唐的想法。所以，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"珍爱生命，远离赌博，尤其是你对概率一无所知的情况下"},{"Type":"NodeText","Data":"！"}]}]},{"ID":"20250421134638-odmjz0c","Type":"NodeParagraph","Properties":{"id":"20250421134638-odmjz0c","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"下面，我们通过 Python 程序来生成一组随机号码。"}]},{"ID":"20250421134638-09go8v1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-09go8v1","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n双色球随机选号程序\n\nAuthor: 骆昊\nVersion: 1.0\n\"\"\"\nimport random\n\nred_balls = list(range(1, 34))\nselected_balls = []\n# 添加6个红色球到选中列表\nfor _ in range(6):\n    # 生成随机整数代表选中的红色球的索引位置\n    index = random.randrange(len(red_balls))\n    # 将选中的球从红色球列表中移除并添加到选中列表\n    selected_balls.append(red_balls.pop(index))\n# 对选中的红色球排序\nselected_balls.sort()\n# 输出选中的红色球\nfor ball in selected_balls:\n    print(f'\\033[031m{ball:0\u003e2d}\\033[0m', end=' ')\n# 随机选择1个蓝色球\nblue_ball = random.randrange(1, 17)\n# 输出选中的蓝色球\nprint(f'\\033[034m{blue_ball:0\u003e2d}\\033[0m')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-0wekdwj","Type":"NodeBlockquote","Properties":{"id":"20250421134638-0wekdwj","updated":"20250421134638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134638-1oqkyvq","Type":"NodeParagraph","Properties":{"id":"20250421134638-1oqkyvq","updated":"20250421134638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：上面代码中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"print(f'\\033[0m...\\033[0m')"},{"Type":"NodeText","Data":"​是为了控制输出内容的颜色，红色球输出成红色，蓝色球输出成蓝色。其中省略号代表我们要输出的内容，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\\033[0m"},{"Type":"NodeText","Data":"​是一个控制码，表示关闭所有属性，也就是说之前的控制码将会失效，你也可以将其简单的理解为一个定界符，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​前面的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​表示控制台的显示方式为默认值，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​可以省略，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"1"},{"Type":"NodeText","Data":"​表示高亮，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"5"},{"Type":"NodeText","Data":"​表示闪烁，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"7"},{"Type":"NodeText","Data":"​表示反显等。在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"0"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m"},{"Type":"NodeText","Data":"​的中间，我们可以写上代表颜色的数字，比如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"30"},{"Type":"NodeText","Data":"​代表黑色，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"31"},{"Type":"NodeText","Data":"​代表红色，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"32"},{"Type":"NodeText","Data":"​代表绿色，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"33"},{"Type":"NodeText","Data":"​代表黄色，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"34"},{"Type":"NodeText","Data":"​代表蓝色等。"}]}]},{"ID":"20250421134638-2m02a2r","Type":"NodeParagraph","Properties":{"id":"20250421134638-2m02a2r","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"我们还可以利用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"random"},{"Type":"NodeText","Data":"​模块提供的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sample"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"choice"},{"Type":"NodeText","Data":"​函数来简化上面的代码，前者可以实现无放回随机抽样，后者可以实现随机抽取一个元素，修改后的代码如下所示。"}]},{"ID":"20250421134638-s5v3xpa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-s5v3xpa","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n双色球随机选号程序\n\nAuthor: 骆昊\nVersion: 1.1\n\"\"\"\nimport random\n\nred_balls = [i for i in range(1, 34)]\nblue_balls = [i for i in range(1, 17)]\n# 从红色球列表中随机抽出6个红色球（无放回抽样）\nselected_balls = random.sample(red_balls, 6)\n# 对选中的红色球排序\nselected_balls.sort()\n# 输出选中的红色球\nfor ball in selected_balls:\n    print(f'\\033[031m{ball:0\u003e2d}\\033[0m', end=' ')\n# 从蓝色球列表中随机抽出1个蓝色球\nblue_ball = random.choice(blue_balls)\n# 输出选中的蓝色球\nprint(f'\\033[034m{blue_ball:0\u003e2d}\\033[0m')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-dga1qe4","Type":"NodeParagraph","Properties":{"id":"20250421134638-dga1qe4","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"如果要实现随机生成"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​注号码，我们只需要将上面的代码放到一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"N"},{"Type":"NodeText","Data":"​次的循环中，如下所示。"}]},{"ID":"20250421134638-gkafshs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-gkafshs","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n双色球随机选号程序\n\nAuthor: 骆昊\nVersion: 1.2\n\"\"\"\nimport random\n\nn = int(input('生成几注号码: '))\nred_balls = [i for i in range(1, 34)]\nblue_balls = [i for i in range(1, 17)]\nfor _ in range(n):\n    # 从红色球列表中随机抽出6个红色球（无放回抽样）\n    selected_balls = random.sample(red_balls, 6)\n    # 对选中的红色球排序\n    selected_balls.sort()\n    # 输出选中的红色球\n    for ball in selected_balls:\n        print(f'\\033[031m{ball:0\u003e2d}\\033[0m', end=' ')\n    # 从蓝色球列表中随机抽出1个蓝色球\n    blue_ball = random.choice(blue_balls)\n    # 输出选中的蓝色球\n    print(f'\\033[034m{blue_ball:0\u003e2d}\\033[0m')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-elvsbl0","Type":"NodeParagraph","Properties":{"id":"20250421134638-elvsbl0","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"我们在 PyCharm 中运行上面的代码，输入"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"5"},{"Type":"NodeText","Data":"​，运行效果如下图所示。"}]},{"ID":"20250421134638-d7vany9","Type":"NodeParagraph","Properties":{"id":"20250421134638-d7vany9","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://github.com/jackfrued/Python-100-Days/raw/master/Day01-20/res/day09/lottery_run_result.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/lottery_run_result.png","TextMarkTextContent":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/lottery_run_result.png"}]},{"ID":"20250421134638-c42gna6","Type":"NodeParagraph","Properties":{"id":"20250421134638-c42gna6","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"这里顺便给大家介绍一个名为 rich 的 Python 三方库，它可以帮助我们用最简单的方式产生最漂亮的输出，你可以在终端中使用 Python 包管理工具 pip 来安装这个三方库，对于使用 PyCharm 的用户，当然要在 PyCharm 的终端窗口使用 pip 命令将 rich 安装到项目的虚拟环境中，命令如下所示。"}]},{"ID":"20250421134638-zeu618s","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-zeu618s","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"c2hlbGw="},{"Type":"NodeCodeBlockCode","Data":"pip install rich\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-vj7v1uj","Type":"NodeParagraph","Properties":{"id":"20250421134638-vj7v1uj","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://github.com/jackfrued/Python-100-Days/raw/master/Day01-20/res/day09/run_pip_in_terminal.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/run_pip_in_terminal.png","TextMarkTextContent":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/run_pip_in_terminal.png"}]},{"ID":"20250421134638-nrirrwo","Type":"NodeParagraph","Properties":{"id":"20250421134638-nrirrwo","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"如上图所示，rich 安装成功后，我们可以用如下所示的代码来控制输出。"}]},{"ID":"20250421134638-fucnjol","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250421134638-fucnjol","updated":"20250421134638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"\"\"\"\n双色球随机选号程序\n\nAuthor: 骆昊\nVersion: 1.3\n\"\"\"\nimport random\n\nfrom rich.console import Console\nfrom rich.table import Table\n\n# 创建控制台\nconsole = Console()\n\nn = int(input('生成几注号码: '))\nred_balls = [i for i in range(1, 34)]\nblue_balls = [i for i in range(1, 17)]\n\n# 创建表格并添加表头\ntable = Table(show_header=True)\nfor col_name in ('序号', '红球', '蓝球'):\n    table.add_column(col_name, justify='center')\n\nfor i in range(n):\n    selected_balls = random.sample(red_balls, 6)\n    selected_balls.sort()\n    blue_ball = random.choice(blue_balls)\n    # 向表格中添加行（序号，红色球，蓝色球）\n    table.add_row(\n        str(i + 1),\n        f'[red]{\" \".join([f\"{ball:0\u003e2d}\" for ball in selected_balls])}[/red]',\n        f'[blue]{blue_ball:0\u003e2d}[/blue]'\n    )\n\n# 通过控制台输出表格\nconsole.print(table)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250421134638-867f673","Type":"NodeBlockquote","Properties":{"id":"20250421134638-867f673","updated":"20250421134638"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20250421134638-his8o15","Type":"NodeParagraph","Properties":{"id":"20250421134638-his8o15","updated":"20250421134638"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"说明"},{"Type":"NodeText","Data":"：上面代码第 31 行使用了列表生成式语法将红色球号码处理成字符串并保存在一个列表中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\" \".join([...])"},{"Type":"NodeText","Data":"​是将列表中的多个字符串用空格拼接成一个完整的字符串，如果不理解可以先放放。字符串中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[red]...[/red]"},{"Type":"NodeText","Data":"​用来设置输出颜色为红色，第 32 行的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[blue]...[/blue]"},{"Type":"NodeText","Data":"​用来设置输出颜色为蓝色。更多关于 rich 库的知识，可以参考"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/textualize/rich/blob/master/README.cn.md","TextMarkTextContent":"官方文档"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20250421134638-nobesrg","Type":"NodeParagraph","Properties":{"id":"20250421134638-nobesrg","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"最终的输出如下图所示，看着这样的输出，是不是心情更美好了一些。"}]},{"ID":"20250421134638-1oznxea","Type":"NodeParagraph","Properties":{"id":"20250421134638-1oznxea","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://github.com/jackfrued/Python-100-Days/raw/master/Day01-20/res/day09/output_using_rich.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/output_using_rich.png","TextMarkTextContent":"https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/res/day09/output_using_rich.png"}]},{"ID":"20250421134638-latr0eu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250421134638-latr0eu","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20250421134638-a4ehonc","Type":"NodeParagraph","Properties":{"id":"20250421134638-a4ehonc","updated":"20250421134638"},"Children":[{"Type":"NodeText","Data":"Python 中的列表底层是一个可以动态扩容的数组，列表元素在计算机内存中是连续存储的，所以可以实现随机访问（通过一个有效的索引获取对应的元素且操作时间与列表元素个数无关）。我们可以暂时不去触碰这些底层的存储细节，也不需要大家理解列表每个方法的渐近时间复杂度（执行方法耗费的时间跟列表元素个数之间的关系），大家先学会用列表解决工作中的问题，我想这一点更为重要。"}]}]}